import logging

from trello import (
    Board,
    TrelloClient
)


logging.basicConfig(filename='trello_webhook_module.log', level=logging.DEBUG)


class trello_watch_boards_for_user(NebriOS):
    # This script requires the user to set the following KVPs:
    # 
    # trello_watch_boards_for_user := True
    # trello_api_key := <the appKey for the app that the user authorized>
    # trello_token := <the token generated by the app for the user who authorized>
    
    listens_to = ['trello_watch_boards_for_user']

    def check(self):
        if self.trello_token is None:
            try:
                self.trello_token = Process.objects.get(user=self.last_actor, kind="oauth_token").token
            except:
                raise Exception('Token does not exist. Please supply one or run trello_webhook_setup.')
                return False
        if self.trello_watch_boards_for_user is True:
            return self.verify_user()
        
        return False
    
    def action(self):
        logging.debug('Doing trello_watch_boards_for_user action...')

        client = self.get_client()
        me = self.get_me()
        logging.debug(me)
        logging.debug(dir(me))
        
        # Setup backup board and list
        backup_board_id, backup_list_id = self.setup_backup_board(client, me)
        
        # Create webhook for member so we can watch if he becomes part of a new board
        logging.debug('Creating webhook for Member %s' % me['id'])
        client.create_hook(
            self.get_hook_url(shared.TRELLO_WEBHOOK_MEMBER_CALLBACK_URL),
            me['id'],
        )
        
        if not shared.TRELLO_BOARD_LIST_TREE:
            shared.TRELLO_BOARD_LIST_TREE = []
        existing_boards = [b.id for b in shared.TRELLO_BOARD_LIST_TREE]

        # Create webhooks for all boards that the member is a part of
        boards = client.list_boards()
        
        for board in boards:
            lists = [{'id':list.id, 'name':list.name} for list in board.all_lists()]
            if board.id not in existing_boards:
                shared.TRELLO_BOARD_LIST_TREE.append({
                    'board_name': board.name,
                    'board_id': board.id,
                    'lists': lists
                })
            else:
                existing_board = [b for b in shared.TRELLO_BOARD_LIST_TREE if b['id'] == board.id]
                for l in lists:
                    if l in existing_board['lists']:
                        continue
                    existing_board['lists'].append(l)
            logging.debug('### board.id != backup_board_id ###')
            logging.debug('%s != %s' % (board.id, backup_board_id,))
            logging.debug('###################################')
            if board.id != backup_board_id:
                logging.debug('Creating webhook for Board %s' % board.id)
                client.create_hook(
                    self.get_hook_url(shared.TRELLO_WEBHOOK_BOARD_CALLBACK_URL),
                    board.id
                )
                
                self.cache_cards_for_board(client, board.id)
            
        logging.debug('Done with trello_watch_boards_for_user action...')
        logging.debug('************************************************')
    
    def cache_cards_for_board(self, client, board_id):
        # Fetch cards for this board
        cards_json = client.fetch_json('/boards/' + board_id + '/cards', query_params={
            'actions': 'all',
            'checklists': 'all',
            'attachments': 'true',
            'filter': 'all'
        })

        for card_json in cards_json:
            logging.debug('Saving card as shared KVP...')
            setattr(shared, 'TRELLO_CARD_%s' % card_json['id'], card_json)

    def get_client(self):
        return TrelloClient(
            api_key=shared.TRELLO_API_KEY,
            api_secret=shared.TRELLO_API_SECRET,
            token=self.trello_token
        )
    
    def get_me(self):
        client = self.get_client()
        return client.fetch_json('/members/me')
    
    def setup_backup_board(self, client, user):
        # Check if we already have a backup board and list already
        cached_member_data = self.get_cached_member_data(user['id']) or {}
        backup_board_id = cached_member_data.get('backup_board_id', None)
        backup_list_id = cached_member_data.get('backup_list_id', None)
        
        create_backup_board = True
        create_backup_list = True
        backup_board = None
        backup_list = None
        try:
            if backup_board_id:
                # Check if the backup board is open
                backup_board = client.get_board(backup_board_id)
                if not backup_board.closed:
                    create_backup_board = False
        except Exception, e:
            logging.debug('Exception while fetching backup board: %s' % e)

        logging.debug('create_backup_board: %s' % create_backup_board)
        if create_backup_board:        
            # Create board and list that would serve as backup for board for the user
            logging.debug('Creating backup board and list for Member %s' % user['id'])
            backup_board_json = client.fetch_json(
                '/boards',
                http_method='POST',
                post_args={
                    'name': 'Backup Board'
                }
            )

            backup_board = Board.from_json(trello_client=client, json_obj=backup_board_json)
        
        # At this point, we should alread have a backup_board instance
        try:
            if backup_list_id:
                # Check if backup_list is in backup_board that we have
                backup_list = backup_board.get_list(backup_list_id)
                if backup_list.board.id == backup_board.id and not backup_list.closed:
                    create_backup_list = False
        except Exception, e:
            logging.debug('Exception while fetching backup list: %s' % e)
        
        create_backup_list = create_backup_board or create_backup_list
        logging.debug('create_backup_list: %s' % create_backup_list)
        if create_backup_list:
            if create_backup_board:
                # We have a newly-created board, let's close all the
                # list that comes with it
                for list in backup_board.all_lists():
                    logging.debug('Closing list %s' % list.id)
                    list.close()

            # Create backup list
            backup_list = backup_board.add_list('Backup List')
        
        # Cache everything that should be cached
        cached_member_data = self.get_cached_member_data(user['id']) or {}
        cached_member_data.update({
            'backup_board_id': backup_board.id,
            'backup_list_id': backup_list.id
        })
        self.set_cached_member_data(user['id'], cached_member_data)
        
        return backup_board.id, backup_list.id
    
    def get_cached_member_data_key(self, member_id):
        return 'TRELLO_MEMBER_DATA_%s' % member_id
    
    def get_cached_member_data(self, member_id):
        cached_member_data = getattr(shared, self.get_cached_member_data_key(member_id))
        return cached_member_data
    
    def set_cached_member_data(self, member_id, cached_member_data):
        setattr(
            shared,
            self.get_cached_member_data_key(member_id),
            cached_member_data
        )

    def verify_user(self):
        verified = False
        # Try authenticating with the credentials provided
        # We should not get an authorization error
        
        try:
            self.get_me()
            verified = True
        except Exception as e:
            # We failed to authenticate with the provided credentials
            raise Exception(str(e))
        
        return verified

    def get_hook_url(self, base_url):
        return '%s?trello_api_key=%s&trello_token=%s' % (
            base_url,
            shared.TRELLO_API_KEY,
            self.trello_token
        )